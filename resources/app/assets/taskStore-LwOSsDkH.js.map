{"version":3,"file":"taskStore-LwOSsDkH.js","sources":["../../src/stores/taskStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { devtools } from 'zustand/middleware';\r\nimport { Task, CreateTaskForm, ApiResponse } from '../../../shared/types';\r\n\r\ninterface TaskFilters {\r\n  categoryId?: number;\r\n  status?: Task['status'];\r\n  priority?: Task['priority'];\r\n  searchQuery?: string;\r\n}\r\n\r\ninterface TaskStore {\r\n  // State\r\n  tasks: Task[];\r\n  filteredTasks: Task[];\r\n  filters: TaskFilters;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  selectedTask: Task | null;\r\n\r\n  // Actions\r\n  fetchTasks: (filters?: TaskFilters) => Promise<void>;\r\n  createTask: (taskData: CreateTaskForm) => Promise<Task>;\r\n  updateTask: (id: number, updates: Partial<Task>) => Promise<Task>;\r\n  deleteTask: (id: number) => Promise<void>;\r\n  completeTask: (id: number) => Promise<Task>;\r\n  setFilters: (filters: Partial<TaskFilters>) => void;\r\n  setSelectedTask: (task: Task | null) => void;\r\n  clearError: () => void;\r\n  \r\n  // Computed getters\r\n  getTasksByCategory: (categoryId: number) => Task[];\r\n  getTasksByStatus: (status: Task['status']) => Task[];\r\n  getOverdueTasks: () => Task[];\r\n  getDueTodayTasks: () => Task[];\r\n  \r\n  // Helper methods\r\n  applyFilters: (tasks: Task[], filters: TaskFilters) => Task[];\r\n}\r\n\r\nconst API_BASE = 'http://localhost:8765/api';\r\n\r\n// Helper function to parse task dates from API responses\r\nconst parseTaskDates = (task: any): Task => {\r\n  return {\r\n    ...task,\r\n    dueDate: task.dueDate ? new Date(task.dueDate) : undefined,\r\n    completedAt: task.completedAt ? new Date(task.completedAt) : undefined,\r\n    createdAt: new Date(task.createdAt),\r\n    updatedAt: new Date(task.updatedAt),\r\n  };\r\n};\r\n\r\nexport const useTaskStore = create<TaskStore>()(\r\n  devtools(\r\n    (set, get) => ({\r\n      // Initial state\r\n      tasks: [],\r\n      filteredTasks: [],\r\n      filters: {},\r\n      isLoading: false,\r\n      error: null,\r\n      selectedTask: null,\r\n\r\n      // Actions\r\n      fetchTasks: async (filters?: TaskFilters) => {\r\n        set({ isLoading: true, error: null });\r\n        \r\n        try {\r\n          const queryParams = new URLSearchParams();\r\n          if (filters?.categoryId) queryParams.append('categoryId', filters.categoryId.toString());\r\n          if (filters?.status) queryParams.append('status', filters.status);\r\n          if (filters?.priority) queryParams.append('priority', filters.priority);\r\n\r\n          const response = await fetch(`${API_BASE}/tasks?${queryParams}`);\r\n          const result: ApiResponse<Task[]> = await response.json();\r\n\r\n          if (!result.success) {\r\n            throw new Error(result.error?.message || 'Failed to fetch tasks');\r\n          }\r\n\r\n          const rawTasks = result.data || [];\r\n          const tasks = rawTasks.map(parseTaskDates);\r\n          set({ \r\n            tasks, \r\n            filteredTasks: get().applyFilters(tasks, get().filters),\r\n            isLoading: false \r\n          });\r\n        } catch (error) {\r\n          set({ \r\n            error: error instanceof Error ? error.message : 'Failed to fetch tasks',\r\n            isLoading: false \r\n          });\r\n        }\r\n      },\r\n\r\n      createTask: async (taskData: CreateTaskForm) => {\r\n        set({ isLoading: true, error: null });\r\n        \r\n        try {\r\n          const response = await fetch(`${API_BASE}/tasks`, {\r\n            method: 'POST',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(taskData),\r\n          });\r\n\r\n          const result: ApiResponse<Task> = await response.json();\r\n\r\n          if (!result.success) {\r\n            throw new Error(result.error?.message || 'Failed to create task');\r\n          }\r\n\r\n          const rawTask = result.data!;\r\n          const newTask = parseTaskDates(rawTask);\r\n          const currentTasks = get().tasks;\r\n          const updatedTasks = [newTask, ...currentTasks];\r\n          \r\n          set({ \r\n            tasks: updatedTasks,\r\n            filteredTasks: get().applyFilters(updatedTasks, get().filters),\r\n            isLoading: false \r\n          });\r\n\r\n          return newTask;\r\n        } catch (error) {\r\n          set({ \r\n            error: error instanceof Error ? error.message : 'Failed to create task',\r\n            isLoading: false \r\n          });\r\n          throw error;\r\n        }\r\n      },\r\n\r\n      updateTask: async (id: number, updates: Partial<Task>) => {\r\n        set({ isLoading: true, error: null });\r\n        \r\n        try {\r\n          const response = await fetch(`${API_BASE}/tasks/${id}`, {\r\n            method: 'PUT',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(updates),\r\n          });\r\n\r\n          const result: ApiResponse<Task> = await response.json();\r\n\r\n          if (!result.success) {\r\n            throw new Error(result.error?.message || 'Failed to update task');\r\n          }\r\n\r\n          const rawTask = result.data!;\r\n          const updatedTask = parseTaskDates(rawTask);\r\n          const currentTasks = get().tasks;\r\n          const updatedTasks = currentTasks.map(task => \r\n            task.id === id ? updatedTask : task\r\n          );\r\n          \r\n          set({ \r\n            tasks: updatedTasks,\r\n            filteredTasks: get().applyFilters(updatedTasks, get().filters),\r\n            selectedTask: get().selectedTask?.id === id ? updatedTask : get().selectedTask,\r\n            isLoading: false \r\n          });\r\n\r\n          return updatedTask;\r\n        } catch (error) {\r\n          set({ \r\n            error: error instanceof Error ? error.message : 'Failed to update task',\r\n            isLoading: false \r\n          });\r\n          throw error;\r\n        }\r\n      },\r\n\r\n      deleteTask: async (id: number) => {\r\n        set({ isLoading: true, error: null });\r\n        \r\n        try {\r\n          const response = await fetch(`${API_BASE}/tasks/${id}`, {\r\n            method: 'DELETE',\r\n          });\r\n\r\n          const result: ApiResponse<void> = await response.json();\r\n\r\n          if (!result.success) {\r\n            throw new Error(result.error?.message || 'Failed to delete task');\r\n          }\r\n\r\n          const currentTasks = get().tasks;\r\n          const updatedTasks = currentTasks.filter(task => task.id !== id);\r\n          \r\n          set({ \r\n            tasks: updatedTasks,\r\n            filteredTasks: get().applyFilters(updatedTasks, get().filters),\r\n            selectedTask: get().selectedTask?.id === id ? null : get().selectedTask,\r\n            isLoading: false \r\n          });\r\n        } catch (error) {\r\n          set({ \r\n            error: error instanceof Error ? error.message : 'Failed to delete task',\r\n            isLoading: false \r\n          });\r\n          throw error;\r\n        }\r\n      },\r\n\r\n      completeTask: async (id: number) => {\r\n        set({ isLoading: true, error: null });\r\n        \r\n        try {\r\n          const response = await fetch(`${API_BASE}/tasks/${id}/complete`, {\r\n            method: 'PATCH',\r\n          });\r\n\r\n          const result: ApiResponse<Task> = await response.json();\r\n\r\n          if (!result.success) {\r\n            throw new Error(result.error?.message || 'Failed to complete task');\r\n          }\r\n\r\n          const rawTask = result.data!;\r\n          const completedTask = parseTaskDates(rawTask);\r\n          const currentTasks = get().tasks;\r\n          const updatedTasks = currentTasks.map(task => \r\n            task.id === id ? completedTask : task\r\n          );\r\n          \r\n          set({ \r\n            tasks: updatedTasks,\r\n            filteredTasks: get().applyFilters(updatedTasks, get().filters),\r\n            selectedTask: get().selectedTask?.id === id ? completedTask : get().selectedTask,\r\n            isLoading: false \r\n          });\r\n\r\n          return completedTask;\r\n        } catch (error) {\r\n          set({ \r\n            error: error instanceof Error ? error.message : 'Failed to complete task',\r\n            isLoading: false \r\n          });\r\n          throw error;\r\n        }\r\n      },\r\n\r\n      setFilters: (newFilters: Partial<TaskFilters>) => {\r\n        const updatedFilters = { ...get().filters, ...newFilters };\r\n        const filteredTasks = get().applyFilters(get().tasks, updatedFilters);\r\n        \r\n        set({ \r\n          filters: updatedFilters,\r\n          filteredTasks \r\n        });\r\n      },\r\n\r\n      setSelectedTask: (task: Task | null) => {\r\n        set({ selectedTask: task });\r\n      },\r\n\r\n      clearError: () => {\r\n        set({ error: null });\r\n      },\r\n\r\n      // Computed getters\r\n      getTasksByCategory: (categoryId: number) => {\r\n        return get().tasks.filter(task => task.categoryId === categoryId);\r\n      },\r\n\r\n      getTasksByStatus: (status: Task['status']) => {\r\n        return get().tasks.filter(task => task.status === status);\r\n      },\r\n\r\n      getOverdueTasks: () => {\r\n        const now = new Date();\r\n        return get().tasks.filter(task => \r\n          task.dueDate && \r\n          task.dueDate < now && \r\n          task.status === 'active'\r\n        );\r\n      },\r\n\r\n      getDueTodayTasks: () => {\r\n        const today = new Date();\r\n        const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());\r\n        const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);\r\n        \r\n        return get().tasks.filter(task => \r\n          task.dueDate && \r\n          task.dueDate >= startOfDay && \r\n          task.dueDate < endOfDay && \r\n          task.status === 'active'\r\n        );\r\n      },\r\n\r\n      // Helper function to apply filters (not exposed in interface)\r\n      applyFilters: (tasks: Task[], filters: TaskFilters): Task[] => {\r\n        let filtered = [...tasks];\r\n\r\n        if (filters.categoryId) {\r\n          filtered = filtered.filter(task => task.categoryId === filters.categoryId);\r\n        }\r\n\r\n        if (filters.status) {\r\n          filtered = filtered.filter(task => task.status === filters.status);\r\n        }\r\n\r\n        if (filters.priority) {\r\n          filtered = filtered.filter(task => task.priority === filters.priority);\r\n        }\r\n\r\n        if (filters.searchQuery) {\r\n          const query = filters.searchQuery.toLowerCase();\r\n          filtered = filtered.filter(task => \r\n            task.title.toLowerCase().includes(query) ||\r\n            (task.description && task.description.toLowerCase().includes(query))\r\n          );\r\n        }\r\n\r\n        return filtered;\r\n      },\r\n    } as TaskStore),\r\n    {\r\n      name: 'task-store',\r\n    }\r\n  )\r\n);"],"names":["API_BASE","parseTaskDates","task","dueDate","Date","completedAt","createdAt","updatedAt","useTaskStore","create","devtools","set","get","tasks","filteredTasks","filters","isLoading","error","selectedTask","fetchTasks","async","queryParams","URLSearchParams","categoryId","append","toString","status","priority","response","fetch","result","json","success","Error","message","data","map","applyFilters","createTask","taskData","method","headers","body","JSON","stringify","rawTask","newTask","updatedTasks","updateTask","id","updates","updatedTask","deleteTask","filter","completeTask","completedTask","setFilters","newFilters","updatedFilters","setSelectedTask","clearError","getTasksByCategory","getTasksByStatus","getOverdueTasks","now","getDueTodayTasks","today","startOfDay","getFullYear","getMonth","getDate","endOfDay","filtered","searchQuery","query","toLowerCase","title","includes","description","name"],"mappings":"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"}
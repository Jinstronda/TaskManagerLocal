{"version":3,"file":"mindfulnessStore-BwCctBeq.js","sources":["../../src/services/BackgroundTimerClient.ts","../../src/stores/timerStore.ts","../../src/stores/mindfulnessStore.ts"],"sourcesContent":["import { Session } from '../../../shared/types';\r\n\r\nexport interface BackgroundTimerStatus {\r\n  timerState: any;\r\n  remainingTime: number;\r\n  isIdle: boolean;\r\n}\r\n\r\nexport class BackgroundTimerClient {\r\n  private clientId: string;\r\n  private heartbeatInterval: number | null = null;\r\n  private statusCheckInterval: number | null = null;\r\n  private readonly HEARTBEAT_INTERVAL = 30000; // 30 seconds\r\n  private readonly STATUS_CHECK_INTERVAL = 1000; // 1 second\r\n\r\n  constructor() {\r\n    this.clientId = this.generateClientId();\r\n    this.startHeartbeat();\r\n  }\r\n\r\n  /**\r\n   * Start a background timer on the server\r\n   */\r\n  public async startTimer(\r\n    sessionType: Session['sessionType'],\r\n    plannedDuration: number,\r\n    taskId?: number,\r\n    categoryId?: number\r\n  ): Promise<{ sessionId: number; timerState: any }> {\r\n    const response = await fetch('/api/timer/start', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Client-Id': this.clientId,\r\n      },\r\n      body: JSON.stringify({\r\n        sessionType,\r\n        plannedDuration,\r\n        taskId,\r\n        categoryId,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to start background timer');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to start background timer');\r\n    }\r\n\r\n    this.startStatusChecking();\r\n    return result.data;\r\n  }\r\n\r\n  /**\r\n   * Pause the background timer\r\n   */\r\n  public async pauseTimer(): Promise<void> {\r\n    const response = await fetch('/api/timer/pause', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Client-Id': this.clientId,\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to pause background timer');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to pause background timer');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resume the background timer\r\n   */\r\n  public async resumeTimer(): Promise<void> {\r\n    const response = await fetch('/api/timer/resume', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Client-Id': this.clientId,\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to resume background timer');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to resume background timer');\r\n    }\r\n\r\n    this.startStatusChecking();\r\n  }\r\n\r\n  /**\r\n   * Stop the background timer\r\n   */\r\n  public async stopTimer(): Promise<void> {\r\n    const response = await fetch('/api/timer/stop', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Client-Id': this.clientId,\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to stop background timer');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to stop background timer');\r\n    }\r\n\r\n    this.stopStatusChecking();\r\n  }\r\n\r\n  /**\r\n   * Complete the background timer\r\n   */\r\n  public async completeTimer(qualityRating?: number, notes?: string): Promise<void> {\r\n    const response = await fetch('/api/timer/complete', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Client-Id': this.clientId,\r\n      },\r\n      body: JSON.stringify({\r\n        qualityRating,\r\n        notes,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to complete background timer');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to complete background timer');\r\n    }\r\n\r\n    this.stopStatusChecking();\r\n  }\r\n\r\n  /**\r\n   * Get timer status from server\r\n   */\r\n  public async getTimerStatus(): Promise<BackgroundTimerStatus> {\r\n    const response = await fetch('/api/timer/status', {\r\n      method: 'GET',\r\n      headers: {\r\n        'X-Client-Id': this.clientId,\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to get timer status');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to get timer status');\r\n    }\r\n\r\n    return result.data;\r\n  }\r\n\r\n  /**\r\n   * Test notification system\r\n   */\r\n  public async testNotification(): Promise<void> {\r\n    const response = await fetch('/api/timer/test-notification', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to send test notification');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to send test notification');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get system tray status\r\n   */\r\n  public async getTrayStatus(): Promise<any> {\r\n    const response = await fetch('/api/timer/tray-status', {\r\n      method: 'GET',\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to get tray status');\r\n    }\r\n\r\n    const result = await response.json();\r\n    if (!result.success) {\r\n      throw new Error(result.error?.message || 'Failed to get tray status');\r\n    }\r\n\r\n    return result.data;\r\n  }\r\n\r\n  /**\r\n   * Start sending heartbeat to server for idle detection\r\n   */\r\n  private startHeartbeat(): void {\r\n    if (this.heartbeatInterval) return;\r\n\r\n    this.heartbeatInterval = window.setInterval(async () => {\r\n      try {\r\n        await fetch('/api/timer/heartbeat', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            'X-Client-Id': this.clientId,\r\n          },\r\n        });\r\n      } catch (error) {\r\n        console.warn('Failed to send heartbeat:', error);\r\n      }\r\n    }, this.HEARTBEAT_INTERVAL);\r\n  }\r\n\r\n  /**\r\n   * Stop sending heartbeat\r\n   */\r\n  private stopHeartbeat(): void {\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n      this.heartbeatInterval = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start checking timer status periodically\r\n   */\r\n  private startStatusChecking(): void {\r\n    if (this.statusCheckInterval) return;\r\n\r\n    let consecutiveFailures = 0;\r\n    const maxFailures = 5;\r\n    let isBackendAvailable = true;\r\n\r\n    this.statusCheckInterval = window.setInterval(async () => {\r\n      try {\r\n        const status = await this.getTimerStatus();\r\n\r\n        // Reset failure count on successful request\r\n        if (consecutiveFailures > 0) {\r\n          consecutiveFailures = 0;\r\n          console.log('üü¢ Backend connection restored');\r\n\r\n          // Emit connection restored event\r\n          window.dispatchEvent(new CustomEvent('timerConnectionRestored', {\r\n            detail: { reconnected: true },\r\n          }));\r\n        }\r\n\r\n        isBackendAvailable = true;\r\n\r\n        // Emit status update event\r\n        window.dispatchEvent(new CustomEvent('timerStatusUpdate', {\r\n          detail: status,\r\n        }));\r\n      } catch (error) {\r\n        consecutiveFailures++;\r\n\r\n        // Only log every few failures to avoid spam\r\n        if (consecutiveFailures <= 3 || consecutiveFailures % 5 === 0) {\r\n          console.warn(`üî¥ Failed to check timer status (${consecutiveFailures}/${maxFailures}):`, error);\r\n        }\r\n\r\n        // If backend becomes unavailable, emit connection lost event\r\n        if (isBackendAvailable && consecutiveFailures >= 3) {\r\n          isBackendAvailable = false;\r\n          console.warn('‚ö†Ô∏è Backend connection lost, timer may be out of sync');\r\n\r\n          window.dispatchEvent(new CustomEvent('timerConnectionLost', {\r\n            detail: {\r\n              failureCount: consecutiveFailures,\r\n              message: 'Backend connection lost, timer may be out of sync'\r\n            },\r\n          }));\r\n        }\r\n\r\n        // Stop checking after too many failures to prevent resource waste\r\n        if (consecutiveFailures >= maxFailures) {\r\n          console.error(`‚ùå Stopping status checks after ${maxFailures} consecutive failures`);\r\n          this.stopStatusChecking();\r\n\r\n          window.dispatchEvent(new CustomEvent('timerConnectionFailed', {\r\n            detail: {\r\n              message: 'Timer synchronization failed, please refresh the page'\r\n            },\r\n          }));\r\n        }\r\n      }\r\n    }, this.STATUS_CHECK_INTERVAL);\r\n  }\r\n\r\n  /**\r\n   * Stop checking timer status\r\n   */\r\n  private stopStatusChecking(): void {\r\n    if (this.statusCheckInterval) {\r\n      clearInterval(this.statusCheckInterval);\r\n      this.statusCheckInterval = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempt to restore connection and restart status checking\r\n   */\r\n  public async attemptReconnection(): Promise<boolean> {\r\n    try {\r\n      console.log('üîÑ Attempting to reconnect to backend...');\r\n      const status = await this.getTimerStatus();\r\n\r\n      // If successful, restart status checking\r\n      this.startStatusChecking();\r\n\r\n      console.log('‚úÖ Reconnection successful');\r\n      window.dispatchEvent(new CustomEvent('timerConnectionRestored', {\r\n        detail: { reconnected: true, manual: true },\r\n      }));\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.warn('‚ùå Reconnection failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate unique client ID\r\n   */\r\n  private generateClientId(): string {\r\n    return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Get client ID\r\n   */\r\n  public getClientId(): string {\r\n    return this.clientId;\r\n  }\r\n\r\n  /**\r\n   * Check if background timer is supported\r\n   */\r\n  public isSupported(): boolean {\r\n    return typeof fetch !== 'undefined';\r\n  }\r\n\r\n  /**\r\n   * Cleanup on service shutdown\r\n   */\r\n  public cleanup(): void {\r\n    this.stopHeartbeat();\r\n    this.stopStatusChecking();\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const backgroundTimerClient = new BackgroundTimerClient();","import { create } from 'zustand';\r\nimport { subscribeWithSelector } from 'zustand/middleware';\r\nimport { Session, SessionPreferences } from '../../../shared/types';\r\nimport { backgroundTimerClient } from '../services/BackgroundTimerClient';\r\n\r\nexport interface TimerState {\r\n  // Core timer state\r\n  isRunning: boolean;\r\n  isPaused: boolean;\r\n  currentSession: Session | null;\r\n  remainingTime: number; // seconds\r\n  sessionType: Session['sessionType'];\r\n  plannedDuration: number; // minutes\r\n  \r\n  // Timer management\r\n  startTime: number | null; // timestamp\r\n  pausedTime: number; // accumulated paused time in seconds\r\n  lastTickTime: number | null; // for accurate time tracking\r\n  \r\n  // Session preferences\r\n  sessionPreferences: SessionPreferences;\r\n  \r\n  // System state\r\n  isSystemSleepDetected: boolean;\r\n  lastActiveTime: number; // timestamp for sleep detection\r\n}\r\n\r\nexport interface TimerActions {\r\n  // Timer controls\r\n  startTimer: (sessionType: Session['sessionType'], duration: number, taskId?: number, categoryId?: number) => void;\r\n  pauseTimer: () => void;\r\n  resumeTimer: () => void;\r\n  stopTimer: () => void;\r\n  tick: () => void;\r\n  \r\n  // Session management\r\n  completeSession: (qualityRating?: number, notes?: string) => Promise<void>;\r\n  updateSessionType: (sessionType: Session['sessionType']) => void;\r\n  updatePlannedDuration: (duration: number) => void;\r\n  \r\n  // Task-session integration\r\n  switchTask: (taskId?: number) => Promise<void>;\r\n  completeCurrentTask: () => Promise<void>;\r\n  updateTaskActualDuration: (taskId: number, additionalMinutes: number) => Promise<void>;\r\n  \r\n  // System integration\r\n  detectSystemSleep: () => void;\r\n  updateLastActiveTime: () => void;\r\n  \r\n  // Preferences\r\n  updateSessionPreferences: (preferences: Partial<SessionPreferences>) => void;\r\n  \r\n  // Reset\r\n  resetTimer: () => void;\r\n  \r\n  // Helper methods\r\n  getDurationForSessionType: (sessionType: Session['sessionType']) => number;\r\n  createSessionOnServer: (session: Session) => Promise<void>;\r\n  updateSessionOnServer: (session: Session) => Promise<void>;\r\n  showCompletionNotification: (session: Session) => void;\r\n}\r\n\r\nexport type TimerStore = TimerState & TimerActions;\r\n\r\n// Default session preferences\r\nconst defaultSessionPreferences: SessionPreferences = {\r\n  deepWorkDuration: 50, // minutes\r\n  quickTaskDuration: 15, // minutes\r\n  breakDuration: 10, // minutes\r\n  customDuration: 25, // minutes\r\n  autoStartBreaks: false,\r\n  soundEnabled: true,\r\n  notificationsEnabled: true,\r\n};\r\n\r\n// Initial state\r\nconst initialState: TimerState = {\r\n  isRunning: false,\r\n  isPaused: false,\r\n  currentSession: null,\r\n  remainingTime: defaultSessionPreferences.deepWorkDuration * 60, // Convert minutes to seconds for initial display\r\n  sessionType: 'deep_work',\r\n  plannedDuration: defaultSessionPreferences.deepWorkDuration,\r\n  startTime: null,\r\n  pausedTime: 0,\r\n  lastTickTime: null,\r\n  sessionPreferences: defaultSessionPreferences,\r\n  isSystemSleepDetected: false,\r\n  lastActiveTime: Date.now(),\r\n};\r\n\r\nexport const useTimerStore = create<TimerStore>()(\r\n  subscribeWithSelector((set, get) => ({\r\n    ...initialState,\r\n\r\n    startTimer: (sessionType, duration, taskId, categoryId = null) => {\r\n      const now = Date.now();\r\n      const newSession: Session = {\r\n        id: 0, // Will be set by server\r\n        ...(taskId !== undefined && { taskId }),\r\n        categoryId,\r\n        sessionType,\r\n        startTime: new Date(now),\r\n        plannedDuration: duration,\r\n        completed: false,\r\n        createdAt: new Date(now),\r\n      };\r\n\r\n      set({\r\n        isRunning: true,\r\n        isPaused: false,\r\n        currentSession: newSession,\r\n        remainingTime: duration * 60, // convert to seconds\r\n        sessionType,\r\n        plannedDuration: duration,\r\n        startTime: now,\r\n        pausedTime: 0,\r\n        lastTickTime: now,\r\n        isSystemSleepDetected: false,\r\n        lastActiveTime: now,\r\n      });\r\n\r\n      // Start the session on the server\r\n      get().createSessionOnServer(newSession);\r\n    },\r\n\r\n    pauseTimer: () => {\r\n      const state = get();\r\n      if (!state.isRunning || state.isPaused) return;\r\n\r\n      set({\r\n        isPaused: true,\r\n        lastTickTime: null,\r\n      });\r\n\r\n      // Pause background timer\r\n      backgroundTimerClient.pauseTimer().catch(error => {\r\n        console.error('Failed to pause background timer:', error);\r\n      });\r\n    },\r\n\r\n    resumeTimer: () => {\r\n      const state = get();\r\n      if (!state.isRunning || !state.isPaused) return;\r\n\r\n      set({\r\n        isPaused: false,\r\n        lastTickTime: Date.now(),\r\n        lastActiveTime: Date.now(),\r\n        isSystemSleepDetected: false,\r\n      });\r\n\r\n      // Resume background timer\r\n      backgroundTimerClient.resumeTimer().catch(error => {\r\n        console.error('Failed to resume background timer:', error);\r\n      });\r\n    },\r\n\r\n    stopTimer: () => {\r\n      const state = get();\r\n      if (!state.isRunning) return;\r\n\r\n      // Calculate actual duration\r\n      const actualDuration = Math.round((state.plannedDuration * 60 - state.remainingTime) / 60);\r\n      \r\n      set({\r\n        isRunning: false,\r\n        isPaused: false,\r\n        remainingTime: 0,\r\n        startTime: null,\r\n        pausedTime: 0,\r\n        lastTickTime: null,\r\n      });\r\n\r\n      // Update session on server if it exists\r\n      if (state.currentSession) {\r\n        get().updateSessionOnServer({\r\n          ...state.currentSession,\r\n          endTime: new Date(),\r\n          actualDuration,\r\n          completed: false, // Stopped, not completed\r\n        });\r\n      }\r\n    },\r\n\r\n    tick: () => {\r\n      const state = get();\r\n      if (!state.isRunning || state.isPaused || !state.lastTickTime) return;\r\n\r\n      const now = Date.now();\r\n      const deltaTime = Math.floor((now - state.lastTickTime) / 1000); // seconds\r\n      \r\n      // Detect potential system sleep (gap > 2 minutes)\r\n      if (deltaTime > 120) {\r\n        set({\r\n          isSystemSleepDetected: true,\r\n          isPaused: true,\r\n          lastTickTime: null,\r\n        });\r\n        return;\r\n      }\r\n\r\n      const newRemainingTime = Math.max(0, state.remainingTime - deltaTime);\r\n      \r\n      set({\r\n        remainingTime: newRemainingTime,\r\n        lastTickTime: now,\r\n        lastActiveTime: now,\r\n      });\r\n\r\n      // Auto-complete session when time runs out\r\n      if (newRemainingTime === 0) {\r\n        get().completeSession();\r\n      }\r\n    },\r\n\r\n    completeSession: async (qualityRating, notes) => {\r\n      const state = get();\r\n      if (!state.currentSession) return;\r\n\r\n      const actualDuration = Math.round((state.plannedDuration * 60 - state.remainingTime) / 60);\r\n      const completedSession: Session = {\r\n        ...state.currentSession!,\r\n        endTime: new Date(),\r\n        actualDuration,\r\n        ...(qualityRating !== undefined && { qualityRating }),\r\n        ...(notes !== undefined && { notes }),\r\n        completed: true,\r\n      };\r\n\r\n      set({\r\n        isRunning: false,\r\n        isPaused: false,\r\n        remainingTime: 0,\r\n        startTime: null,\r\n        pausedTime: 0,\r\n        lastTickTime: null,\r\n        currentSession: null,\r\n      });\r\n\r\n      // Update session on server\r\n      await get().updateSessionOnServer(completedSession);\r\n      \r\n      // Show completion notification\r\n      get().showCompletionNotification(completedSession);\r\n    },\r\n\r\n    updateSessionType: (sessionType) => {\r\n      const state = get();\r\n      const duration = get().getDurationForSessionType(sessionType);\r\n      \r\n      set({\r\n        sessionType,\r\n        plannedDuration: duration,\r\n        remainingTime: state.isRunning ? state.remainingTime : duration * 60,\r\n      });\r\n\r\n      if (state.currentSession) {\r\n        set({\r\n          currentSession: {\r\n            ...state.currentSession,\r\n            sessionType,\r\n            plannedDuration: duration,\r\n          },\r\n        });\r\n      }\r\n    },\r\n\r\n    updatePlannedDuration: (duration) => {\r\n      const state = get();\r\n      set({\r\n        plannedDuration: duration,\r\n        remainingTime: state.isRunning ? state.remainingTime : duration * 60,\r\n      });\r\n\r\n      if (state.currentSession) {\r\n        set({\r\n          currentSession: {\r\n            ...state.currentSession,\r\n            plannedDuration: duration,\r\n          },\r\n        });\r\n      }\r\n    },\r\n\r\n    detectSystemSleep: () => {\r\n      const state = get();\r\n      const now = Date.now();\r\n      const timeSinceLastActive = now - state.lastActiveTime;\r\n      \r\n      // If more than 2 minutes have passed, consider it a system sleep\r\n      if (timeSinceLastActive > 120000 && state.isRunning && !state.isPaused) {\r\n        set({\r\n          isSystemSleepDetected: true,\r\n          isPaused: true,\r\n          lastTickTime: null,\r\n        });\r\n      }\r\n    },\r\n\r\n    updateLastActiveTime: () => {\r\n      set({\r\n        lastActiveTime: Date.now(),\r\n        isSystemSleepDetected: false,\r\n      });\r\n    },\r\n\r\n    updateSessionPreferences: (preferences) => {\r\n      set({\r\n        sessionPreferences: {\r\n          ...get().sessionPreferences,\r\n          ...preferences,\r\n        },\r\n      });\r\n      \r\n      // Save to localStorage for persistence\r\n      localStorage.setItem('sessionPreferences', JSON.stringify(get().sessionPreferences));\r\n    },\r\n\r\n    resetTimer: () => {\r\n      set(initialState);\r\n    },\r\n\r\n    // Helper methods (not part of the store interface but used internally)\r\n    getDurationForSessionType: (sessionType: Session['sessionType']): number => {\r\n      const prefs = get().sessionPreferences;\r\n      switch (sessionType) {\r\n        case 'deep_work':\r\n          return prefs.deepWorkDuration;\r\n        case 'quick_task':\r\n          return prefs.quickTaskDuration;\r\n        case 'break':\r\n          return prefs.breakDuration;\r\n        case 'custom':\r\n          return prefs.customDuration;\r\n        default:\r\n          return prefs.deepWorkDuration;\r\n      }\r\n    },\r\n\r\n    createSessionOnServer: async (session: Session) => {\r\n      try {\r\n        const result = await backgroundTimerClient.startTimer(\r\n          session.sessionType,\r\n          session.plannedDuration,\r\n          session.taskId,\r\n          session.categoryId\r\n        );\r\n        \r\n        set({\r\n          currentSession: {\r\n            ...get().currentSession!,\r\n            id: result.sessionId,\r\n          },\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to create session on server:', error);\r\n      }\r\n    },\r\n\r\n    updateSessionOnServer: async (session: Session) => {\r\n      try {\r\n        if (session.completed) {\r\n          await backgroundTimerClient.completeTimer(session.qualityRating, session.notes);\r\n        } else {\r\n          // For non-completed sessions (stopped), just stop the timer\r\n          await backgroundTimerClient.stopTimer();\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to update session on server:', error);\r\n      }\r\n    },\r\n\r\n    // Task-session integration methods\r\n    switchTask: async (taskId?: number) => {\r\n      const state = get();\r\n      if (!state.currentSession || !state.isRunning) return;\r\n\r\n      // Calculate time spent on current task\r\n      const currentDuration = Math.round((state.plannedDuration * 60 - state.remainingTime) / 60);\r\n      \r\n      // Update current task's actual duration if it exists\r\n      if (state.currentSession.taskId && currentDuration > 0) {\r\n        await get().updateTaskActualDuration(state.currentSession.taskId, currentDuration);\r\n      }\r\n\r\n      // Update current session with new task\r\n      const updatedSession = {\r\n        ...state.currentSession,\r\n        taskId,\r\n        // Reset start time for new task tracking\r\n        startTime: new Date(),\r\n      };\r\n\r\n      set({\r\n        currentSession: updatedSession,\r\n      });\r\n\r\n      // Update session on server\r\n      await get().updateSessionOnServer(updatedSession);\r\n    },\r\n\r\n    completeCurrentTask: async () => {\r\n      const state = get();\r\n      if (!state.currentSession?.taskId) return;\r\n\r\n      try {\r\n        // Calculate final duration for the task\r\n        const sessionDuration = Math.round((state.plannedDuration * 60 - state.remainingTime) / 60);\r\n        \r\n        // Update task's actual duration\r\n        if (sessionDuration > 0) {\r\n          await get().updateTaskActualDuration(state.currentSession.taskId, sessionDuration);\r\n        }\r\n\r\n        // Mark task as complete via API\r\n        const response = await fetch(`http://localhost:8765/api/tasks/${state.currentSession.taskId}/complete`, {\r\n          method: 'PATCH',\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error('Failed to complete task');\r\n        }\r\n\r\n        // Show success notification\r\n        if (get().sessionPreferences.notificationsEnabled) {\r\n          if ('Notification' in window && Notification.permission === 'granted') {\r\n            new Notification('Task Completed!', {\r\n              body: `Task completed with ${sessionDuration} minutes of work`,\r\n              icon: '/favicon.ico',\r\n            });\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to complete task:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    updateTaskActualDuration: async (taskId: number, additionalMinutes: number) => {\r\n      try {\r\n        const response = await fetch(`http://localhost:8765/api/tasks/${taskId}/add-time`, {\r\n          method: 'PATCH',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify({ additionalMinutes }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error('Failed to update task duration');\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to update task actual duration:', error);\r\n        // Don't throw here to avoid breaking the session flow\r\n      }\r\n    },\r\n\r\n    showCompletionNotification: (session: Session) => {\r\n      if (!get().sessionPreferences.notificationsEnabled) return;\r\n      \r\n      const message = `${session.sessionType.replace('_', ' ')} session completed! Duration: ${session.actualDuration} minutes`;\r\n      \r\n      // Use browser notification if available\r\n      if ('Notification' in window && Notification.permission === 'granted') {\r\n        new Notification('Session Complete', {\r\n          body: message,\r\n          icon: '/favicon.ico',\r\n        });\r\n      }\r\n    },\r\n  }))\r\n);\r\n\r\n// Load session preferences from localStorage on initialization\r\nconst savedPreferences = localStorage.getItem('sessionPreferences');\r\nif (savedPreferences) {\r\n  try {\r\n    const preferences = JSON.parse(savedPreferences);\r\n    useTimerStore.getState().updateSessionPreferences(preferences);\r\n  } catch (error) {\r\n    console.error('Failed to load session preferences:', error);\r\n  }\r\n}\r\n\r\n// Backend timer synchronization - Listen for timer status updates from BackgroundTimerClient\r\n// This ensures the frontend UI stays in sync with the backend timer service\r\nif (typeof window !== 'undefined') {\r\n  let syncInterval: number | null = null;\r\n\r\n  // Listen for timer status updates from BackgroundTimerClient\r\n  window.addEventListener('timerStatusUpdate', (event: CustomEvent) => {\r\n    const status = event.detail;\r\n    const currentState = useTimerStore.getState();\r\n\r\n    console.log('üîÑ Timer status update received:', status);\r\n\r\n    // Only sync if we have valid status data from backend\r\n    if (status && typeof status === 'object') {\r\n      const { timerState, remainingTime, isIdle } = status;\r\n\r\n      // If no active timer on backend, ensure frontend reflects stopped state\r\n      if (!timerState && currentState.isRunning) {\r\n        console.log('‚èπÔ∏è Backend timer stopped, updating frontend');\r\n        useTimerStore.setState({\r\n          isRunning: false,\r\n          isPaused: false,\r\n          lastTickTime: null\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Sync backend timer state with frontend\r\n      if (timerState) {\r\n        const { isRunning, isPaused, sessionType, plannedDuration } = timerState;\r\n\r\n        // Update timer state if different from current\r\n        const updates: Partial<TimerState> = {};\r\n\r\n        if (isRunning !== currentState.isRunning) {\r\n          updates.isRunning = isRunning;\r\n          console.log(`üéØ Timer running state: ${isRunning}`);\r\n        }\r\n\r\n        if (isPaused !== currentState.isPaused) {\r\n          updates.isPaused = isPaused;\r\n          console.log(`‚è∏Ô∏è Timer paused state: ${isPaused}`);\r\n        }\r\n\r\n        // Update remaining time if backend provides it and timer is active and not paused\r\n        if (remainingTime !== undefined && remainingTime >= 0 && isRunning && !isPaused) {\r\n          updates.remainingTime = remainingTime;\r\n          updates.lastTickTime = Date.now(); // Update tick time for smooth countdown\r\n          console.log(`‚è±Ô∏è Remaining time: ${remainingTime}s`);\r\n        } else if (isPaused) {\r\n          // When paused, stop the smooth countdown by clearing lastTickTime\r\n          updates.lastTickTime = null;\r\n          console.log(`‚è∏Ô∏è Timer paused, stopping countdown updates`);\r\n        }\r\n\r\n        // Sync session configuration if different\r\n        if (sessionType && sessionType !== currentState.sessionType) {\r\n          updates.sessionType = sessionType;\r\n          console.log(`üìù Session type: ${sessionType}`);\r\n        }\r\n\r\n        if (plannedDuration !== undefined && plannedDuration !== currentState.plannedDuration) {\r\n          updates.plannedDuration = plannedDuration;\r\n          console.log(`‚è∞ Planned duration: ${plannedDuration}min`);\r\n        }\r\n\r\n        // Apply updates if any\r\n        if (Object.keys(updates).length > 0) {\r\n          useTimerStore.setState(updates);\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  // Error recovery with automatic retry\r\n  let retryTimeout: number | null = null;\r\n  let retryAttempts = 0;\r\n  const maxRetryAttempts = 3;\r\n  const retryDelays = [5000, 10000, 30000]; // 5s, 10s, 30s\r\n\r\n  // Handle connection status events for error recovery\r\n  window.addEventListener('timerConnectionLost', (event: CustomEvent) => {\r\n    console.warn('‚ö†Ô∏è Timer connection lost:', event.detail.message);\r\n\r\n    // Start automatic retry with exponential backoff\r\n    if (retryAttempts < maxRetryAttempts) {\r\n      const delay = retryDelays[Math.min(retryAttempts, retryDelays.length - 1)];\r\n      console.log(`üîÑ Will retry connection in ${delay / 1000}s (attempt ${retryAttempts + 1}/${maxRetryAttempts})`);\r\n\r\n      retryTimeout = window.setTimeout(async () => {\r\n        retryAttempts++;\r\n        console.log(`üîÑ Retry attempt ${retryAttempts}/${maxRetryAttempts}`);\r\n\r\n        const success = await backgroundTimerClient.attemptReconnection();\r\n        if (success) {\r\n          retryAttempts = 0; // Reset on success\r\n        }\r\n      }, delay);\r\n    }\r\n  });\r\n\r\n  window.addEventListener('timerConnectionRestored', (event: CustomEvent) => {\r\n    console.log('üü¢ Timer connection restored');\r\n\r\n    // Clear any pending retry attempts\r\n    if (retryTimeout) {\r\n      clearTimeout(retryTimeout);\r\n      retryTimeout = null;\r\n    }\r\n    retryAttempts = 0;\r\n  });\r\n\r\n  window.addEventListener('timerConnectionFailed', (event: CustomEvent) => {\r\n    console.error('‚ùå Timer connection failed permanently:', event.detail.message);\r\n\r\n    // Clear retry attempts - user intervention required\r\n    if (retryTimeout) {\r\n      clearTimeout(retryTimeout);\r\n      retryTimeout = null;\r\n    }\r\n    retryAttempts = maxRetryAttempts;\r\n  });\r\n\r\n  // Start smooth countdown animation using optimistic updates\r\n  // This provides 60fps smooth countdown while staying synced with backend\r\n  const startSmoothCountdown = () => {\r\n    if (syncInterval) {\r\n      clearInterval(syncInterval);\r\n    }\r\n\r\n    syncInterval = window.setInterval(() => {\r\n      const state = useTimerStore.getState();\r\n\r\n      // Only tick if timer is running and not paused and we have a valid lastTickTime\r\n      if (state.isRunning && !state.isPaused && state.lastTickTime) {\r\n        const now = Date.now();\r\n        const deltaSeconds = Math.floor((now - state.lastTickTime) / 1000);\r\n\r\n        // Optimistic update: reduce time by 1 second for smooth animation\r\n        if (deltaSeconds >= 1 && state.remainingTime > 0) {\r\n          const newRemainingTime = Math.max(0, state.remainingTime - 1);\r\n\r\n          useTimerStore.setState({\r\n            remainingTime: newRemainingTime,\r\n            lastTickTime: now\r\n          });\r\n\r\n          // Auto-complete when countdown reaches zero\r\n          if (newRemainingTime === 0) {\r\n            state.completeSession();\r\n          }\r\n        }\r\n      } else if (state.isPaused && state.lastTickTime) {\r\n        // Clear lastTickTime when paused to stop optimistic updates\r\n        useTimerStore.setState({ lastTickTime: null });\r\n      }\r\n    }, 1000); // 1 second intervals for smooth countdown\r\n  };\r\n\r\n  // Subscribe to timer state changes to manage smooth countdown\r\n  useTimerStore.subscribe(\r\n    (state) => ({ isRunning: state.isRunning, isPaused: state.isPaused }),\r\n    (current, previous) => {\r\n      // Start smooth countdown when timer starts or resumes\r\n      if (current.isRunning && !current.isPaused && (!previous.isRunning || previous.isPaused)) {\r\n        startSmoothCountdown();\r\n      }\r\n\r\n      // Stop smooth countdown when timer stops or pauses\r\n      if ((!current.isRunning || current.isPaused) && syncInterval) {\r\n        clearInterval(syncInterval);\r\n        syncInterval = null;\r\n      }\r\n    }\r\n  );\r\n}","import { create } from 'zustand';\r\nimport { subscribeWithSelector } from 'zustand/middleware';\r\n\r\nexport interface MindfulnessState {\r\n  // Active components\r\n  showMindfulnessPrompt: boolean;\r\n  showBreathingExercise: boolean;\r\n  showTransitionAnimation: boolean;\r\n  showSessionReflection: boolean;\r\n  \r\n  // Current states\r\n  currentTransitionType: 'session_start' | 'session_end' | 'break_start' | 'break_end' | 'task_complete' | null;\r\n  currentMindfulnessType: 'session_end' | 'session_start' | 'break_start' | 'manual';\r\n  \r\n  // Settings\r\n  mindfulnessEnabled: boolean;\r\n  transitionAnimationsEnabled: boolean;\r\n  breathingExerciseEnabled: boolean;\r\n  sessionReflectionEnabled: boolean;\r\n  \r\n  // Auto-trigger settings\r\n  autoShowOnSessionEnd: boolean;\r\n  autoShowOnSessionStart: boolean;\r\n  autoShowOnBreakStart: boolean;\r\n  \r\n  // Statistics\r\n  mindfulnessSessionsCompleted: number;\r\n  totalMindfulnessTime: number; // seconds\r\n  favoriteExercises: string[];\r\n  streakDays: number;\r\n  lastMindfulnessDate: Date | null;\r\n}\r\n\r\nexport interface MindfulnessActions {\r\n  // Component visibility\r\n  showMindfulnessPromptModal: (type: MindfulnessState['currentMindfulnessType']) => void;\r\n  hideMindfulnessPrompt: () => void;\r\n  showBreathingExerciseModal: () => void;\r\n  hideBreathingExercise: () => void;\r\n  showTransitionAnimationModal: (type: MindfulnessState['currentTransitionType']) => void;\r\n  hideTransitionAnimation: () => void;\r\n  showSessionReflectionModal: () => void;\r\n  hideSessionReflection: () => void;\r\n  \r\n  // Settings management\r\n  updateMindfulnessSettings: (settings: Partial<Pick<MindfulnessState, \r\n    'mindfulnessEnabled' | 'transitionAnimationsEnabled' | 'breathingExerciseEnabled' | \r\n    'sessionReflectionEnabled' | 'autoShowOnSessionEnd' | 'autoShowOnSessionStart' | 'autoShowOnBreakStart'\r\n  >>) => void;\r\n  \r\n  // Statistics tracking\r\n  recordMindfulnessSession: (exerciseId: string, duration: number) => void;\r\n  updateStreak: () => void;\r\n  addFavoriteExercise: (exerciseId: string) => void;\r\n  removeFavoriteExercise: (exerciseId: string) => void;\r\n  \r\n  // Auto-trigger logic\r\n  checkAutoTriggers: (eventType: 'session_start' | 'session_end' | 'break_start' | 'break_end' | 'task_complete') => void;\r\n  \r\n  // Utility\r\n  resetMindfulnessData: () => void;\r\n  loadSettings: () => void;\r\n  saveSettings: () => void;\r\n}\r\n\r\nexport type MindfulnessStore = MindfulnessState & MindfulnessActions;\r\n\r\n// Initial state\r\nconst initialState: MindfulnessState = {\r\n  showMindfulnessPrompt: false,\r\n  showBreathingExercise: false,\r\n  showTransitionAnimation: false,\r\n  showSessionReflection: false,\r\n  currentTransitionType: null,\r\n  currentMindfulnessType: 'manual',\r\n  mindfulnessEnabled: true,\r\n  transitionAnimationsEnabled: true,\r\n  breathingExerciseEnabled: true,\r\n  sessionReflectionEnabled: true,\r\n  autoShowOnSessionEnd: true,\r\n  autoShowOnSessionStart: false,\r\n  autoShowOnBreakStart: true,\r\n  mindfulnessSessionsCompleted: 0,\r\n  totalMindfulnessTime: 0,\r\n  favoriteExercises: [],\r\n  streakDays: 0,\r\n  lastMindfulnessDate: null,\r\n};\r\n\r\nexport const useMindfulnessStore = create<MindfulnessStore>()(\r\n  subscribeWithSelector((set, get) => ({\r\n    ...initialState,\r\n\r\n    // Component visibility actions\r\n    showMindfulnessPromptModal: (type) => {\r\n      const state = get();\r\n      if (!state.mindfulnessEnabled) return;\r\n      \r\n      set({\r\n        showMindfulnessPrompt: true,\r\n        currentMindfulnessType: type,\r\n      });\r\n    },\r\n\r\n    hideMindfulnessPrompt: () => {\r\n      set({\r\n        showMindfulnessPrompt: false,\r\n      });\r\n    },\r\n\r\n    showBreathingExerciseModal: () => {\r\n      const state = get();\r\n      if (!state.breathingExerciseEnabled) return;\r\n      \r\n      set({\r\n        showBreathingExercise: true,\r\n      });\r\n    },\r\n\r\n    hideBreathingExercise: () => {\r\n      set({\r\n        showBreathingExercise: false,\r\n      });\r\n    },\r\n\r\n    showTransitionAnimationModal: (type) => {\r\n      const state = get();\r\n      if (!state.transitionAnimationsEnabled) return;\r\n      \r\n      set({\r\n        showTransitionAnimation: true,\r\n        currentTransitionType: type,\r\n      });\r\n    },\r\n\r\n    hideTransitionAnimation: () => {\r\n      set({\r\n        showTransitionAnimation: false,\r\n        currentTransitionType: null,\r\n      });\r\n    },\r\n\r\n    showSessionReflectionModal: () => {\r\n      const state = get();\r\n      if (!state.sessionReflectionEnabled) return;\r\n      \r\n      set({\r\n        showSessionReflection: true,\r\n      });\r\n    },\r\n\r\n    hideSessionReflection: () => {\r\n      set({\r\n        showSessionReflection: false,\r\n      });\r\n    },\r\n\r\n    // Settings management\r\n    updateMindfulnessSettings: (settings) => {\r\n      set(settings);\r\n      get().saveSettings();\r\n    },\r\n\r\n    // Statistics tracking\r\n    recordMindfulnessSession: (exerciseId, duration) => {\r\n      set(state => ({\r\n        mindfulnessSessionsCompleted: state.mindfulnessSessionsCompleted + 1,\r\n        totalMindfulnessTime: state.totalMindfulnessTime + duration,\r\n        lastMindfulnessDate: new Date(),\r\n      }));\r\n      \r\n      // Update streak\r\n      get().updateStreak();\r\n      \r\n      // Add to favorites if used multiple times\r\n      const state = get();\r\n      const exerciseCount = state.favoriteExercises.filter(id => id === exerciseId).length;\r\n      if (exerciseCount >= 3 && !state.favoriteExercises.includes(exerciseId)) {\r\n        get().addFavoriteExercise(exerciseId);\r\n      }\r\n      \r\n      get().saveSettings();\r\n    },\r\n\r\n    updateStreak: () => {\r\n      const state = get();\r\n      const today = new Date();\r\n      const lastDate = state.lastMindfulnessDate;\r\n      \r\n      if (!lastDate) {\r\n        set({ streakDays: 1 });\r\n        return;\r\n      }\r\n      \r\n      const daysDiff = Math.floor((today.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24));\r\n      \r\n      if (daysDiff === 0) {\r\n        // Same day, no change to streak\r\n        return;\r\n      } else if (daysDiff === 1) {\r\n        // Consecutive day, increment streak\r\n        set(state => ({ streakDays: state.streakDays + 1 }));\r\n      } else {\r\n        // Streak broken, reset to 1\r\n        set({ streakDays: 1 });\r\n      }\r\n    },\r\n\r\n    addFavoriteExercise: (exerciseId) => {\r\n      set(state => ({\r\n        favoriteExercises: [...state.favoriteExercises.filter(id => id !== exerciseId), exerciseId],\r\n      }));\r\n    },\r\n\r\n    removeFavoriteExercise: (exerciseId) => {\r\n      set(state => ({\r\n        favoriteExercises: state.favoriteExercises.filter(id => id !== exerciseId),\r\n      }));\r\n    },\r\n\r\n    // Auto-trigger logic\r\n    checkAutoTriggers: (eventType) => {\r\n      const state = get();\r\n      \r\n      if (!state.mindfulnessEnabled) return;\r\n      \r\n      switch (eventType) {\r\n        case 'session_start':\r\n          if (state.autoShowOnSessionStart) {\r\n            // Show transition animation first, then mindfulness prompt\r\n            get().showTransitionAnimationModal('session_start');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n              get().showMindfulnessPromptModal('session_start');\r\n            }, 3000);\r\n          } else if (state.transitionAnimationsEnabled) {\r\n            get().showTransitionAnimationModal('session_start');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n            }, 3000);\r\n          }\r\n          break;\r\n          \r\n        case 'session_end':\r\n          if (state.autoShowOnSessionEnd) {\r\n            // Show transition animation first, then reflection or mindfulness\r\n            get().showTransitionAnimationModal('session_end');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n              if (state.sessionReflectionEnabled) {\r\n                get().showSessionReflectionModal();\r\n              } else {\r\n                get().showMindfulnessPromptModal('session_end');\r\n              }\r\n            }, 3000);\r\n          } else if (state.transitionAnimationsEnabled) {\r\n            get().showTransitionAnimationModal('session_end');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n            }, 3000);\r\n          }\r\n          break;\r\n          \r\n        case 'break_start':\r\n          if (state.autoShowOnBreakStart) {\r\n            get().showTransitionAnimationModal('break_start');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n              get().showMindfulnessPromptModal('break_start');\r\n            }, 3000);\r\n          } else if (state.transitionAnimationsEnabled) {\r\n            get().showTransitionAnimationModal('break_start');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n            }, 3000);\r\n          }\r\n          break;\r\n          \r\n        case 'break_end':\r\n          if (state.transitionAnimationsEnabled) {\r\n            get().showTransitionAnimationModal('break_end');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n            }, 3000);\r\n          }\r\n          break;\r\n          \r\n        case 'task_complete':\r\n          if (state.transitionAnimationsEnabled) {\r\n            get().showTransitionAnimationModal('task_complete');\r\n            setTimeout(() => {\r\n              get().hideTransitionAnimation();\r\n            }, 3000);\r\n          }\r\n          break;\r\n      }\r\n    },\r\n\r\n    // Utility functions\r\n    resetMindfulnessData: () => {\r\n      set({\r\n        mindfulnessSessionsCompleted: 0,\r\n        totalMindfulnessTime: 0,\r\n        favoriteExercises: [],\r\n        streakDays: 0,\r\n        lastMindfulnessDate: null,\r\n      });\r\n      get().saveSettings();\r\n    },\r\n\r\n    loadSettings: () => {\r\n      try {\r\n        const saved = localStorage.getItem('mindfulnessSettings');\r\n        if (saved) {\r\n          const settings = JSON.parse(saved);\r\n          set({\r\n            ...settings,\r\n            lastMindfulnessDate: settings.lastMindfulnessDate ? new Date(settings.lastMindfulnessDate) : null,\r\n          });\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to load mindfulness settings:', error);\r\n      }\r\n    },\r\n\r\n    saveSettings: () => {\r\n      try {\r\n        const state = get();\r\n        const settingsToSave = {\r\n          mindfulnessEnabled: state.mindfulnessEnabled,\r\n          transitionAnimationsEnabled: state.transitionAnimationsEnabled,\r\n          breathingExerciseEnabled: state.breathingExerciseEnabled,\r\n          sessionReflectionEnabled: state.sessionReflectionEnabled,\r\n          autoShowOnSessionEnd: state.autoShowOnSessionEnd,\r\n          autoShowOnSessionStart: state.autoShowOnSessionStart,\r\n          autoShowOnBreakStart: state.autoShowOnBreakStart,\r\n          mindfulnessSessionsCompleted: state.mindfulnessSessionsCompleted,\r\n          totalMindfulnessTime: state.totalMindfulnessTime,\r\n          favoriteExercises: state.favoriteExercises,\r\n          streakDays: state.streakDays,\r\n          lastMindfulnessDate: state.lastMindfulnessDate?.toISOString(),\r\n        };\r\n        \r\n        localStorage.setItem('mindfulnessSettings', JSON.stringify(settingsToSave));\r\n      } catch (error) {\r\n        console.error('Failed to save mindfulness settings:', error);\r\n      }\r\n    },\r\n  }))\r\n);\r\n\r\n// Load settings on initialization\r\nuseMindfulnessStore.getState().loadSettings();"],"names":["backgroundTimerClient","clientId","heartbeatInterval","statusCheckInterval","HEARTBEAT_INTERVAL","STATUS_CHECK_INTERVAL","constructor","this","generateClientId","startHeartbeat","startTimer","sessionType","plannedDuration","taskId","categoryId","response","fetch","method","headers","body","JSON","stringify","ok","Error","result","json","success","error","message","startStatusChecking","data","pauseTimer","resumeTimer","stopTimer","stopStatusChecking","completeTimer","qualityRating","notes","getTimerStatus","testNotification","getTrayStatus","window","setInterval","async","stopHeartbeat","clearInterval","consecutiveFailures","isBackendAvailable","status","dispatchEvent","CustomEvent","detail","reconnected","failureCount","attemptReconnection","manual","Date","now","Math","random","toString","substr","getClientId","isSupported","cleanup","defaultSessionPreferences","deepWorkDuration","quickTaskDuration","breakDuration","customDuration","autoStartBreaks","soundEnabled","notificationsEnabled","initialState","isRunning","isPaused","currentSession","remainingTime","startTime","pausedTime","lastTickTime","sessionPreferences","isSystemSleepDetected","lastActiveTime","useTimerStore","create","subscribeWithSelector","set","get","duration","newSession","id","completed","createdAt","createSessionOnServer","state","catch","actualDuration","round","updateSessionOnServer","endTime","tick","deltaTime","floor","newRemainingTime","max","completeSession","completedSession","showCompletionNotification","updateSessionType","getDurationForSessionType","updatePlannedDuration","detectSystemSleep","updateLastActiveTime","updateSessionPreferences","preferences","localStorage","setItem","resetTimer","prefs","session","sessionId","switchTask","currentDuration","updateTaskActualDuration","updatedSession","completeCurrentTask","sessionDuration","Notification","permission","icon","additionalMinutes","replace","savedPreferences","getItem","parse","getState","syncInterval","addEventListener","event","currentState","timerState","isIdle","setState","updates","Object","keys","length","retryTimeout","retryAttempts","maxRetryAttempts","retryDelays","delay","min","setTimeout","clearTimeout","startSmoothCountdown","subscribe","current","previous","showMindfulnessPrompt","showBreathingExercise","showTransitionAnimation","showSessionReflection","currentTransitionType","currentMindfulnessType","mindfulnessEnabled","transitionAnimationsEnabled","breathingExerciseEnabled","sessionReflectionEnabled","autoShowOnSessionEnd","autoShowOnSessionStart","autoShowOnBreakStart","mindfulnessSessionsCompleted","totalMindfulnessTime","favoriteExercises","streakDays","lastMindfulnessDate","useMindfulnessStore","showMindfulnessPromptModal","type","hideMindfulnessPrompt","showBreathingExerciseModal","hideBreathingExercise","showTransitionAnimationModal","hideTransitionAnimation","showSessionReflectionModal","hideSessionReflection","updateMindfulnessSettings","settings","saveSettings","recordMindfulnessSession","exerciseId","updateStreak","filter","includes","addFavoriteExercise","today","lastDate","daysDiff","getTime","removeFavoriteExercise","checkAutoTriggers","eventType","resetMindfulnessData","loadSettings","saved","settingsToSave","toISOString"],"mappings":"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"}